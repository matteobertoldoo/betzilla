{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nimport { ethers } from 'ethers';\nimport BetZillaArtifact from '../abi/BetZilla.json';\nconst BetZillaABI = BetZillaArtifact.abi;\n\n// Contract address from latest deployment\nconst CONTRACT_ADDRESS = '0x5fbdb2315678afecb367f032d93f642f64180aa3';\nexport const useBetzilla = () => {\n  _s();\n  const [contract, setContract] = useState(null);\n  const [signer, setSigner] = useState(null);\n  const [account, setAccount] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  // Check if wallet is already connected\n  const checkWalletConnection = async () => {\n    try {\n      if (!window.ethereum) {\n        return false;\n      }\n      const accounts = await window.ethereum.request({\n        method: 'eth_accounts'\n      });\n      if (accounts.length > 0) {\n        // Usa direttamente window.ethereum senza \"any\"\n        const provider = new ethers.BrowserProvider(window.ethereum);\n        const network = await provider.getNetwork();\n        console.log('Connected network:', network.chainId);\n        const signer = await provider.getSigner();\n        setAccount(accounts[0]);\n        setSigner(signer);\n\n        // Create contract instance\n        const contractInstance = new ethers.Contract(CONTRACT_ADDRESS, BetZillaABI, signer);\n        setContract(contractInstance);\n        return true;\n      }\n      return false;\n    } catch (err) {\n      console.error('Error checking wallet connection:', err);\n      return false;\n    }\n  };\n\n  // Connect to MetaMask\n  const connectWallet = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      if (!window.ethereum) {\n        throw new Error('MetaMask not installed');\n      }\n\n      // Request account access\n      const accounts = await window.ethereum.request({\n        method: 'eth_requestAccounts'\n      });\n      const provider = new ethers.BrowserProvider(window.ethereum);\n      const signer = await provider.getSigner();\n      setAccount(accounts[0]);\n      setSigner(signer);\n\n      // Create contract instance\n      const contractInstance = new ethers.Contract(CONTRACT_ADDRESS, BetZillaABI, signer);\n      setContract(contractInstance);\n      return accounts[0];\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Initialize wallet connection on app start\n  useEffect(() => {\n    const initializeWallet = async () => {\n      if (!isInitialized) {\n        await checkWalletConnection();\n        setIsInitialized(true);\n      }\n    };\n    initializeWallet();\n  }, [isInitialized]);\n\n  // Listen for account changes\n  useEffect(() => {\n    if (window.ethereum) {\n      const handleAccountsChanged = accounts => {\n        if (accounts.length > 0) {\n          setAccount(accounts[0]);\n          // Recreate contract instance with new signer\n          const provider = new ethers.BrowserProvider(window.ethereum);\n          provider.getSigner().then(signer => {\n            setSigner(signer);\n            const contractInstance = new ethers.Contract(CONTRACT_ADDRESS, BetZillaABI, signer);\n            setContract(contractInstance);\n          });\n        } else {\n          setAccount(null);\n          setContract(null);\n          setSigner(null);\n        }\n      };\n      window.ethereum.on('accountsChanged', handleAccountsChanged);\n      return () => {\n        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);\n      };\n    }\n  }, []);\n\n  // Place a bet\n  const placeBet = async (marketId, outcome, amount) => {\n    if (!contract || !signer) {\n      throw new Error('Wallet not connected');\n    }\n    try {\n      setLoading(true);\n      setError(null);\n      console.log(`ðŸŽ¯ Placing bet: Market ${marketId}, Outcome ${outcome}, Amount ${amount} ETH`);\n      const tx = await contract.placeBet(marketId, outcome, {\n        value: ethers.parseEther(amount.toString())\n      });\n      console.log(`ðŸ“ Transaction hash: ${tx.hash}`);\n      const receipt = await tx.wait();\n      console.log(`âœ… Bet placed successfully! Block: ${receipt.blockNumber}`);\n      return receipt;\n    } catch (err) {\n      console.error('âŒ Error placing bet:', err);\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Get market info\n  const getMarket = async marketId => {\n    if (!contract) {\n      throw new Error('Contract not connected');\n    }\n    try {\n      const market = await contract.markets(marketId);\n      return market;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Get user bet\n  const getUserBet = async marketId => {\n    if (!contract || !account) {\n      throw new Error('Wallet not connected');\n    }\n    try {\n      const bet = await contract.bets(marketId, account);\n      return bet;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Get all user bets (check multiple markets)\n  const getAllUserBets = async () => {\n    if (!contract || !account) {\n      throw new Error('Wallet not connected');\n    }\n    try {\n      const userBets = [];\n      const marketCount = Number(await contract.marketCount());\n      for (let marketId = 1; marketId <= marketCount; marketId++) {\n        try {\n          const bet = await contract.bets(marketId, account);\n          if (bet && bet.amount > 0) {\n            const market = await contract.markets(marketId);\n            userBets.push({\n              marketId,\n              bet,\n              market\n            });\n          }\n        } catch (error) {\n          // skip\n        }\n      }\n      return userBets;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Claim winnings\n  const claimWinnings = async marketId => {\n    if (!contract || !signer) {\n      throw new Error('Wallet not connected');\n    }\n    try {\n      setLoading(true);\n      setError(null);\n      const tx = await contract.claimWinnings(marketId);\n      const receipt = await tx.wait();\n      return receipt;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Get match details from backend\n  const getMatchDetails = async marketId => {\n    try {\n      const response = await fetch(`http://localhost:4000/api/matches`);\n      const data = await response.json();\n      if (data.success && data.matches) {\n        // Find match by ID (marketId corresponds to match id)\n        const match = data.matches.find(m => m.id === marketId);\n        return match || null;\n      }\n      return null;\n    } catch (error) {\n      console.error('Error fetching match details:', error);\n      return null;\n    }\n  };\n  return {\n    contract,\n    signer,\n    account,\n    loading,\n    error,\n    connectWallet,\n    placeBet,\n    getMarket,\n    getUserBet,\n    getAllUserBets,\n    claimWinnings,\n    getMatchDetails\n  };\n};\n_s(useBetzilla, \"4l3HEItAnwSDeqZYy/BbtdlCgVo=\");","map":{"version":3,"names":["useState","useEffect","ethers","BetZillaArtifact","BetZillaABI","abi","CONTRACT_ADDRESS","useBetzilla","_s","contract","setContract","signer","setSigner","account","setAccount","loading","setLoading","error","setError","isInitialized","setIsInitialized","checkWalletConnection","window","ethereum","accounts","request","method","length","provider","BrowserProvider","network","getNetwork","console","log","chainId","getSigner","contractInstance","Contract","err","connectWallet","Error","message","initializeWallet","handleAccountsChanged","then","on","removeListener","placeBet","marketId","outcome","amount","tx","value","parseEther","toString","hash","receipt","wait","blockNumber","getMarket","market","markets","getUserBet","bet","bets","getAllUserBets","userBets","marketCount","Number","push","claimWinnings","getMatchDetails","response","fetch","data","json","success","matches","match","find","m","id"],"sources":["/home/matteo/Scrivania/new/frontend/src/hooks/useBetzilla.js"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport { ethers } from 'ethers';\nimport BetZillaArtifact from '../abi/BetZilla.json';\nconst BetZillaABI = BetZillaArtifact.abi;\n\n// Contract address from latest deployment\nconst CONTRACT_ADDRESS = '0x5fbdb2315678afecb367f032d93f642f64180aa3';\n\nexport const useBetzilla = () => {\n  const [contract, setContract] = useState(null);\n  const [signer, setSigner] = useState(null);\n  const [account, setAccount] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  // Check if wallet is already connected\n  const checkWalletConnection = async () => {\n    try {\n      if (!window.ethereum) {\n        return false;\n      }\n\n      const accounts = await window.ethereum.request({\n        method: 'eth_accounts',\n      });\n\n      if (accounts.length > 0) {\n        // Usa direttamente window.ethereum senza \"any\"\n        const provider = new ethers.BrowserProvider(window.ethereum);\n        const network = await provider.getNetwork();\n        console.log('Connected network:', network.chainId);\n        const signer = await provider.getSigner();\n        \n        setAccount(accounts[0]);\n        setSigner(signer);\n\n        // Create contract instance\n        const contractInstance = new ethers.Contract(\n          CONTRACT_ADDRESS,\n          BetZillaABI,\n          signer\n        );\n        setContract(contractInstance);\n        return true;\n      }\n      return false;\n    } catch (err) {\n      console.error('Error checking wallet connection:', err);\n      return false;\n    }\n  };\n\n  // Connect to MetaMask\n  const connectWallet = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      if (!window.ethereum) {\n        throw new Error('MetaMask not installed');\n      }\n\n      // Request account access\n      const accounts = await window.ethereum.request({\n        method: 'eth_requestAccounts',\n      });\n\n      const provider = new ethers.BrowserProvider(window.ethereum);\n      const signer = await provider.getSigner();\n      \n      setAccount(accounts[0]);\n      setSigner(signer);\n\n      // Create contract instance\n      const contractInstance = new ethers.Contract(\n        CONTRACT_ADDRESS,\n        BetZillaABI,\n        signer\n      );\n      setContract(contractInstance);\n\n      return accounts[0];\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Initialize wallet connection on app start\n  useEffect(() => {\n    const initializeWallet = async () => {\n      if (!isInitialized) {\n        await checkWalletConnection();\n        setIsInitialized(true);\n      }\n    };\n\n    initializeWallet();\n  }, [isInitialized]);\n\n  // Listen for account changes\n  useEffect(() => {\n    if (window.ethereum) {\n      const handleAccountsChanged = (accounts) => {\n        if (accounts.length > 0) {\n          setAccount(accounts[0]);\n          // Recreate contract instance with new signer\n          const provider = new ethers.BrowserProvider(window.ethereum);\n          provider.getSigner().then(signer => {\n            setSigner(signer);\n            const contractInstance = new ethers.Contract(\n              CONTRACT_ADDRESS,\n              BetZillaABI,\n              signer\n            );\n            setContract(contractInstance);\n          });\n        } else {\n          setAccount(null);\n          setContract(null);\n          setSigner(null);\n        }\n      };\n\n      window.ethereum.on('accountsChanged', handleAccountsChanged);\n\n      return () => {\n        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);\n      };\n    }\n  }, []);\n\n  // Place a bet\n  const placeBet = async (marketId, outcome, amount) => {\n    if (!contract || !signer) {\n      throw new Error('Wallet not connected');\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n\n      console.log(`ðŸŽ¯ Placing bet: Market ${marketId}, Outcome ${outcome}, Amount ${amount} ETH`);\n\n      const tx = await contract.placeBet(marketId, outcome, {\n        value: ethers.parseEther(amount.toString())\n      });\n\n      console.log(`ðŸ“ Transaction hash: ${tx.hash}`);\n      const receipt = await tx.wait();\n      console.log(`âœ… Bet placed successfully! Block: ${receipt.blockNumber}`);\n      \n      return receipt;\n    } catch (err) {\n      console.error('âŒ Error placing bet:', err);\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Get market info\n  const getMarket = async (marketId) => {\n    if (!contract) {\n      throw new Error('Contract not connected');\n    }\n\n    try {\n      const market = await contract.markets(marketId);\n      return market;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Get user bet\n  const getUserBet = async (marketId) => {\n    if (!contract || !account) {\n      throw new Error('Wallet not connected');\n    }\n\n    try {\n      const bet = await contract.bets(marketId, account);\n      return bet;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Get all user bets (check multiple markets)\n  const getAllUserBets = async () => {\n    if (!contract || !account) {\n      throw new Error('Wallet not connected');\n    }\n\n    try {\n      const userBets = [];\n      const marketCount = Number(await contract.marketCount());\n      for (let marketId = 1; marketId <= marketCount; marketId++) {\n        try {\n          const bet = await contract.bets(marketId, account);\n          if (bet && bet.amount > 0) {\n            const market = await contract.markets(marketId);\n            userBets.push({\n              marketId,\n              bet,\n              market\n            });\n          }\n        } catch (error) {\n          // skip\n        }\n      }\n      return userBets;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Claim winnings\n  const claimWinnings = async (marketId) => {\n    if (!contract || !signer) {\n      throw new Error('Wallet not connected');\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n\n      const tx = await contract.claimWinnings(marketId);\n      const receipt = await tx.wait();\n      return receipt;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Get match details from backend\n  const getMatchDetails = async (marketId) => {\n    try {\n      const response = await fetch(`http://localhost:4000/api/matches`);\n      const data = await response.json();\n      \n      if (data.success && data.matches) {\n        // Find match by ID (marketId corresponds to match id)\n        const match = data.matches.find(m => m.id === marketId);\n        return match || null;\n      }\n      return null;\n    } catch (error) {\n      console.error('Error fetching match details:', error);\n      return null;\n    }\n  };\n\n  return {\n    contract,\n    signer,\n    account,\n    loading,\n    error,\n    connectWallet,\n    placeBet,\n    getMarket,\n    getUserBet,\n    getAllUserBets,\n    claimWinnings,\n    getMatchDetails,\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}